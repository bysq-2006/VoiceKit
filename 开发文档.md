# 语音助手 - 开发文档

> 本文档用于理解项目架构，同时作为 AI 开发基准提示词。项目开发遵循非必要不添加，不要因为不存在的需求而多开发代码。写的代码要精简，简洁。

## 项目概述

一个基于 Tauri + Vue3 的桌面语音助手应用，核心设计理念：**状态驱动**——前端只修改状态变量，后端监听状态变化并执行对应工作流。

## 核心原则

```
┌─────────────────────────────────────────────────────────┐
│  前端 (Frontend)                                         │
│  ├── 仅负责 UI 渲染                                      │
│  ├── 仅负责修改状态变量                                  │
│  └── 通过 invoke 修改状态，通过 event 监听后端状态       │
├─────────────────────────────────────────────────────────┤
│  后端 (Backend)                                          │
│  ├── 监听状态变化，自动执行工作流                        │
│  ├── 管理音频缓冲区                                      │
│  ├── 管理文字缓冲区                                      │
│  ├── 调用语音转文字 API（双向流）                        │
│  ├── 模拟键盘输入到当前焦点                              │
│  └── 管理配置存储 (Store)                                │
└─────────────────────────────────────────────────────────┘
```


## 状态流转

```
用户按下快捷键 (如 Shift+E)
        ↓
后端: Shortcut Handler → 切换 is_recording
        ↓
前端: 更新 UI 状态
        ↓
后端: Recorder 监控到状态变化
        ├── 开始录音 → AudioBuffer
        └── 停止录音 → AudioBuffer.finish()
        
VAD 模块 (待实现)
        ↓
检测到语音开始 → ASRManager.create_provider() → provider.start()
        ↓
持续从 AudioBuffer 读取 → WebSocket 发送 → 接收结果 → TextBuffer
        ↓
检测到语音结束 → provider.stop()
        ↓
TextBuffer.finish()
        ↓
InputSimulator: 读取 TextBuffer → 模拟键盘输入
```


## 后端
### 核心储存
- `models/state.rs`: AppState（is_recording, config, audio_buffer, text_buffer, asr_manager）
- `models/buffer.rs`: AudioBuffer（录音 → ASR）、TextBuffer（ASR → 输入模拟）
- `models/config.rs`: 配置信息

### 录音
`recorder.rs`: 独立线程监控 is_recording
- 开始录音: 清空 AudioBuffer，启动录音流（重采样至 16kHz 单声道）
- 停止录音: 停止录音流，AudioBuffer.finish()（不清空，ASR 继续读取）

### ASR 模块
`src-tauri/src/asr/`: WebSocket 双向流语音识别，识别结果写入 TextBuffer。
- `manager.rs` 为工厂模式，存储各 ASR 实现（讯飞/豆包），根据配置创建对应的 Provider 实例。
- Provider 需实现 `start()` 和 `stop()`: `start()` 建立 WebSocket 连接后持续从 AudioBuffer 读取音频发送，接收识别结果写入 TextBuffer; `stop()` 发送结束帧并断开连接。

#### 豆包 ASR 文本处理逻辑
豆包每次返回完整文本（而非增量），需做增量更新：
1. 缓存上次返回的文本
2. 新旧文本从左往右对比，找到第一个不同字符位置
3. 回退旧文本中该位置之后的字符
4. 输入新文本中该位置之后的字符
- 工具函数: `utils/text_diff.rs::compute_diff(old, new) -> (backspace_count, addition)`
- 退格实现: `TextBuffer::send_backspaces()` 发送批量退格标记，由 `InputSimulator` 解析并执行

### 模拟输入
`input_simulator.rs`: 独立线程循环读取 TextBuffer，有数据立即模拟键盘输入
- 输入前设置 `is_simulating_input` 标志，用于跳过全局监听

### 全局输入监听
`global_input.rs`: 录音状态下监听全局键盘/鼠标，任意输入取消录音
- 依赖 `rdev` 库实现跨平台全局事件监听
- 模拟输入期间自动忽略（检测 `is_simulating_input` 标志）

### 录音控制
`utils/recording.rs`: 录音状态统一控制
- `toggle()`: 切换录音状态
- `set()`: 设置录音状态
- 内置 200ms 防抖，避免重复触发
- 自动发送 `recording-state-changed` 事件到前端

---

## 发布流程（GitHub Actions 自动构建）

项目已配置 GitHub Actions，推送 tag 后会自动构建 Windows 安装包并发布到 Releases。

### 发布步骤

```bash
# 1. 修改版本号（两个文件都要改）
# - package.json: "version": "0.1.1"
# - src-tauri/tauri.conf.json: "version": "0.1.1"

# 2. 提交代码
git add -A
git commit -m "release: v0.1.1 - 更新内容描述"
git push origin main

# 3. 打 tag 触发自动构建
git tag v0.1.1
git push origin v0.1.1
```

### 等待构建完成

1. 访问 GitHub 仓库 → **Actions** 标签页查看构建进度
2. 构建完成后，访问 **Releases** 页面
3. 会看到自动创建的 Draft Release，检查无误后点击 **Publish** 发布

### 生成的文件

- `VoiceKit_x64-setup.exe` - Windows 安装包（NSIS）

### 注意事项

- 版本号格式：`v*.*.*`（如 v0.1.1）
- 构建约需 **5-10 分钟**
- 只有 push tag 才会触发构建，普通 push 不会
 